{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Benvenuto","text":"<p>\ud83d\ude80 Scopri le funzionalit\u00e0 di Service Mesh e gRPC con questa demo!</p> <p>Questa demo ti guider\u00e0 attraverso le principali caratteristiche della service mesh e del protocollo gRPC , offrendoti un'anteprima pratica di ci\u00f2 che puoi fare.</p>"},{"location":"#cosa-troverai-in-questa-demo","title":"Cosa troverai in questa demo?","text":"<ul> <li>\u2705 Introduzione al progetto: una panoramica sulle funzionalit\u00e0 principali.</li> <li>\ud83d\udee0 Installazione e configurazione: istruzioni per iniziare rapidamente.</li> <li>\ud83d\udcd6 Guida all'uso: esempi pratici e suggerimenti utili.</li> <li>\ud83d\udca1 FAQ e supporto: risposte alle domande pi\u00f9 comuni.</li> </ul> <p>Buon proseguimento! \ud83d\ude80</p>"},{"location":"grpc/","title":"gRPC","text":"<p>Utilizza protocol buffer che per la serializzazione/deserializzazione \u00e8 molto pi\u00f9 performante rispetto ad un JSON visto che sono byte scambiati. Tra gli svantaggi si pu\u00f2 notare che il debugging, ad esempio, \u00e8 pi\u00f9 ostico perch\u00e8 si necessita di avere un qualcosa che trasforma quei dati in formato leggibili (altrimenti rimangono byte).</p>"},{"location":"grpc/#grpc-senza-istio-opzione-con-headless-service","title":"gRPC senza Istio opzione con headless service","text":"<p>Il motivo principale per cui \u00e8 difficile bilanciare il traffico gRPC \u00e8 che le persone vedono gRPC come HTTP ed \u00e8 qui che inizia il problema, in base alla progettazione sono diversi, mentre HTTP crea e chiude le connessioni per richiesta, gRPC opera su un protocollo HTTP2 che funziona su una connessione TCP di lunga durata che rende pi\u00f9 difficile il bilanciamento poich\u00e9 pi\u00f9 richieste passano attraverso la stessa connessione grazie alla funzione multiplex.</p> <p>Senza la service mesh \u00e8 necessario implementare soluzioni alternative per gestire efficacemente il bilanciamento del carico del traffico gRPC in Kubernetes. Queste soluzioni possono includere la configurazione diretta dei client per gestire pi\u00f9 connessioni server o l'utilizzo di proxy come meccanismo di bilanciamento</p>"},{"location":"grpc/#proxy-load-balancing","title":"proxy load balancing","text":"<p>Nel bilanciamento del carico proxy, il client invia gli RPC a un proxy Load Balancer (LB). Il LB distribuisce la chiamata RPC a uno dei server backend disponibili che implementano la logica effettiva per servire la chiamata. Il LB tiene traccia del carico su ogni backend e implementa algoritmi per distribuire equamente il carico. I client stessi non conoscono i server backend e possono non essere attendibili.</p>"},{"location":"grpc/#client-side-load-balancing","title":"client-side load balancing","text":"<p>Nel bilanciamento del carico lato client, il client \u00e8 a conoscenza di molti server backend e ne sceglie uno da utilizzare per ogni RPC. Se il client lo desidera, pu\u00f2 implementare gli algoritmi di bilanciamento del carico in base al report di carico dal server. Per una distribuzione semplice, i client possono effettuare il round-robin delle richieste tra i server disponibili.</p>"},{"location":"grpc/#app-grpc-rilasciata-come-helm-chart-in-argocd","title":"App GRPC rilasciata come Helm Chart in ArgoCD","text":""},{"location":"grpc/#1-creazione-namespace-grpc-demo","title":"1. Creazione namespace grpc-demo","text":"<p>Aggiungere annotazione:</p> <pre><code>labels: argocd.argoproj.io/managed-by: openshift-gitops\n</code></pre>"},{"location":"grpc/#2-rilascio-applicazione-quarkus","title":"2. Rilascio applicazione Quarkus","text":"<p>Rilasciamo una applicazione Quarkus che stabilisce una comunicazione client-server con protocollo grpc per verificare la mancanza di bilanciamento (multiplexing)</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: grpc-demo\n  namespace: openshift-gitops\nspec:\n  destination:\n    namespace: grpc-demo\n    server: https://kubernetes.default.svc\n  source:\n    path: grpc/helm-charts/grpc-demo-services\n    repoURL: https://github.com/nictore/ocp-demo.git\n    targetRevision: HEAD\n    helm:\n      releaseName: grpc-demo-services\n      valueFiles:\n      - values.yaml\n  sources: []\n  project: default\n  syncPolicy:\n    syncOptions:\n      - CreateNamespace=true\n</code></pre>"},{"location":"grpc/#3-test-di-comunicazione","title":"3. Test di comunicazione","text":"<p>Accedere al client grpc ed eseguire:</p> <pre><code>oc -n test exec deploy/grpc-client -- curl http://localhost:8080/hello/grpc\n</code></pre> <p>Verificare i log lato server, solo una istanza ha ricevuto i messaggi</p>"},{"location":"grpc/#4-osservazioni","title":"4. Osservazioni","text":"<p>Perch\u00e9 il traffico gRPC non \u00e8 bilanciato correttamente in Kubernetes?</p> <p>Il motivo principale per cui \u00e8 difficile bilanciare il traffico gRPC \u00e8 che spesso... si pensa che gRPC sia come HTTP ed \u00e8 qui che inizia il problema Mentre HTTP crea e chiude connessioni per richiesta, gRPC opera su protocollo HTTP2 che funziona su una connessione TCP di lunga durata rendendo pi\u00f9 difficile il bilanciamento poich\u00e9 pi\u00f9 richieste passano attraverso la stessa connessione grazie alla funzionalit\u00e0 di multiplexing. Tuttavia, ci sono altri errori comuni:</p> <ul> <li>Configurazione errata del client gRPC</li> <li>Configurazione errata del servizio Kubernetes</li> </ul>"},{"location":"grpc/#configurazione-errata-del-client-grpc","title":"Configurazione errata del client gRPC","text":"<p>Il client gRPC come configurazione predefinita prevede un tipo di connessione 1\u20131, in ambiente produttivo non funziona come vorremmo. Il client gRPC predefinito offre la possibilit\u00e0 di connettersi con un semplice record IP/DNS che crea una sola connessione con il servizio di destinazione. Ecco perch\u00e9 \u00e8 necessario effettuare una configurazione diversa.</p> <p>Impostazione di default:</p> <pre><code>func main(){ \n  conn, err := grpc.Dial(\"my-domain:50051\", grpc.WithInsecure()) \n  if err != nil { \n    log.Fatalf(\"errore di connessione con il server gRPC: %v\", err) \n  }\n  ...\n</code></pre> <p>Impostazione consigliata:</p> <pre><code>func main(){ \n  addr := fmt.Sprintf(\"%s:///%s\", \"dns\", \" my-domain :50051\") \n  conn, err := grpc.Dial(addr, grpc.WithInsecure(),grpc.WithBalancerName(roundrobin.Name)) \n  if err != nil { \n    log.Fatalf(\"connessione non riuscita: %v\", err) \n  } \n  ...\n</code></pre> <p>In questo modo nel caso in cui il nostro client si connetta a pi\u00f9 server, ora il nostro client gRPC \u00e8 in grado di bilanciare le richieste in base all'algoritmo di bilanciamento scelto.</p>"},{"location":"grpc/#app-grpc-con-istio","title":"App GRPC con Istio","text":"<p>Rilasciamo la stessa applicazione Quarkus client-server con istio per verificare gestione delle connessioni multiple grazie agli envoy</p>"},{"location":"grpc/#1-creazione-namespace-grpc-demo-istio","title":"1. Creazione namespace grpc-demo-istio","text":"<p>Aggiungere annotazione:</p> <pre><code>labels: argocd.argoproj.io/managed-by: openshift-gitops\n</code></pre>"},{"location":"grpc/#2-aggiornare-servicemeshmemberroll","title":"2. Aggiornare ServiceMeshMemberRoll","text":"<pre><code>apiVersion: maistra.io/v1\nkind: ServiceMeshMemberRoll\nmetadata:\n  name: default\n  namespace: istio-system\nspec:\n  members:\n    - bookinfo\n    - grpc-demo-istio\n</code></pre>"},{"location":"grpc/#3-rilascio-app-grpc-con-istio","title":"3. Rilascio app gRPC con Istio","text":"<pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: grpc-demo-istio\n  namespace: openshift-gitops\nspec:\n  destination:\n    namespace: grpc-demo-istio\n    server: https://kubernetes.default.svc\n  source:\n    path: grpc/helm-charts/grpc-demo-services-istio\n    repoURL: https://github.com/nictore/ocp-demo.git\n    targetRevision: HEAD\n    helm:\n      releaseName: grpc-demo-services-istio\n      valueFiles:\n      - values.yaml\n  sources: []\n  project: default\n  syncPolicy:\n    syncOptions:\n      - CreateNamespace=true\n</code></pre>"},{"location":"grpc/#4-test-di-comunicazione","title":"4. Test di comunicazione","text":"<p>Accedere al client grpc ed eseguire:</p> <pre><code>oc -n test exec deploy/grpc-client -- curl http://localhost:8080/hello/grpc\n</code></pre> <p>Verificare i log lato server, traffico bilanciato correttamente</p>"},{"location":"grpc/#considerazioni-finali","title":"Considerazioni finali","text":"<p>Kubernetes consente ai client di scoprire gli IP dei pod tramite ricerche DNS. Di solito, quando si esegue una ricerca DNS per un servizio, il server DNS restituisce un singolo IP, il cluser IP del servizio. Ma se si comunica a Kubernetes che non \u00e8 necessario un cluster IP per il servizio (lo si fa impostando il campo clusterIP su None nella specifica del servizio), il server DNS restituir\u00e0 gli IP dei pod anzich\u00e9 il singolo IP del servizio. Invece di restituire un singolo record DNS A, il server DNS restituir\u00e0 pi\u00f9 record A per il servizio, ognuno dei quali punta all'IP di un singolo pod che supporta il servizio in quel momento. I client possono quindi effettuare una semplice ricerca di record DNS A e ottenere gli IP di tutti i pod che fanno parte del servizio. Il client pu\u00f2 quindi utilizzare tali informazioni per connettersi a uno, molti o tutti.</p> <p>Impostando il campo clusterIP in una specifica di servizio su None, il servizio diventa headless, poich\u00e9 Kubernetes non gli assegner\u00e0 un IP cluster tramite il quale i client potrebbero connettersi ai pod che lo supportano.</p>"},{"location":"security/","title":"Security","text":"<p>Service Mesh consente di crittografare tutto il traffico senza richiedere modifiche al codice, senza complicati aggiornamenti di rete e senza installare/utilizzare strumenti esterni.</p> <p>Per impostazione predefinita, mTLS in OpenShift Service Mesh viene abilitato e impostato Permissive Mode, i sidecar in Service Mesh accettano sia il traffico in plain text sia le connessioni crittografate tramite mTLS.</p> <p>Abilitando mTLS nella mesh a livello di Control Plane (ServiceMeshControlPlane) \u00e8 possibile proteggere i namespace dichiarati nella mesh. Per personalizzare le connessioni di crittografia del traffico i namespace devono essere configurati con le risorse PeerAuthentication e DestinationRule.</p> <p></p> <p>La CA di Istio genera automaticamente certificati per supportare le connessioni mTLS e li inietta nei pod dell'applicazione. In questo caso, l'utilizzo di mTLS comporta un ulteriore vantaggio poich\u00e9 consente agli amministratori di creare regole di controllo degli accessi basate sui ruoli (RBAC) nel cluster OpenShift per specificare quale client pu\u00f2 connettersi a quali servizi.</p>"},{"location":"security/#abilitare-mtls","title":"Abilitare mTLS","text":"<pre><code>apiVersion: maistra.io/v2\nkind: ServiceMeshControlPlane\nspec:\n  security:\n    dataPlane:\n      mtls: true\n</code></pre> <p>WARNING: Il passaggio alla modalit\u00e0 Enforce \u00e8 facilmente attuabile se i workload non necessitano di comunicare con risorse esterne, perch\u00e8 il traffico in egress dagli envoy viaggia cifrato.</p>"},{"location":"security/#verifica-mtls-status","title":"Verifica mTLS status","text":"<p>La console Kiali offre diversi modi per verificare se le applicazioni, i servizi e i carichi di lavoro hanno la crittografia mTLS abilitata o meno.</p> <p></p> <p>Sul lato destro del masthead, Kiali mostra un'icona a forma di lucchetto quando la mesh ha abilitato rigorosamente mTLS per l'intera service mesh. Ci\u00f2 significa che tutte le comunicazioni nella mesh utilizzano mTLS.</p> <p></p> <p>Kiali visualizza un'icona a forma di lucchetto vuoto quando la mesh \u00e8 configurata in PERMISSIVEmodalit\u00e0 o si verifica un errore nella configurazione mTLS dell'intera mesh.</p>"},{"location":"security/#configurazione-tls-gateway","title":"Configurazione TLS Gateway","text":"<p>Per esporre un gateway in https \u00e8 sufficiente aggiungere all'interno della sua configurazione la sezione TLS con riferimento alla secret contenente certificato e chiave:</p> <pre><code>apiVersion: networking.istio.io/v1beta1\nkind: Gateway\n  name: bookinfo-gateway\n  namespace: bookinfo\nspec:\n  selector:\n    istio: ingressgateway\n  servers:\n    - hosts:\n        - bookinfo.apps.lab.dpastore.uk\n      port:\n        name: https\n        number: 443\n        protocol: HTTPS\n      tls:\n        credentialName: bookinfo-credential\n        mode: SIMPLE\n</code></pre>"},{"location":"security/#controllo-outbound","title":"Controllo outBound","text":"<p>Istio ha un'opzione che consente di configurare i sidecar per abilitare o bloccare connessioni verso servizi esterni, ovvero quei servizi che non sono definiti nel registro della mesh. Di default questa opzione \u00e8 impostata su ALLOW_ANY, il proxy Istio infatti lascia passare le chiamate a servizi sconosciuti. Se l'opzione \u00e8 impostata su REGISTRY_ONLY, il proxy Istio blocca qualsiasi host senza un servizio HTTP o una voce di servizio definita all'interno della mesh.</p> <p>Per il passaggio alla modalit\u00e0 REGISTRY_ONLY aggiungere in ServiceMeshControlPlane:</p> <pre><code>spec:\n   proxy:\n     networking:\n       trafficControl:\n         outbound:\n           policy: REGISTRY_ONLY\n</code></pre> <p>Definire un ServiceEntry per abilitare l'outbound verso un servizio esterno:</p> <pre><code>apiVersion: networking.istio.io/v1alpha3\nkind: ServiceEntry\nmetadata:\n  name: ext-httpbin\n  namespace: bookinfo\nspec:\n  hosts:\n    - httpbin.org\n  location: MESH_EXTERNAL\n  ports:\n    - name: https\n      number: 443\n      protocol: HTTPS\n  resolution: DNS\n</code></pre>"},{"location":"servicemesh/","title":"Service Mesh Demo","text":""},{"location":"servicemesh/#1-requisiti","title":"1. Requisiti","text":""},{"location":"servicemesh/#11-setup-operators","title":"1.1 Setup Operators","text":"<pre><code>1. OpenShift Elasticsearch Operator\n2. Red Hat OpenShift distributed tracing platform\n3. Kiali Operator\n4. Red Hat OpenShift Service Mesh\n</code></pre>"},{"location":"servicemesh/#12-definizione-servicemeshcontrolplane","title":"1.2 Definizione ServiceMeshControlPlane","text":"<pre><code>apiVersion: maistra.io/v2\nkind: ServiceMeshControlPlane\nmetadata:\n  name: basic\n  namespace: istio-system\nspec:\n  addons:\n    grafana:\n      enabled: true\n    jaeger:\n      install:\n        storage:\n          type: Memory\n    kiali:\n      enabled: true\n    prometheus:\n      enabled: true\n  gateways:\n    openshiftRoute:\n      enabled: true\n  mode: MultiTenant\n  policy:\n    type: Istiod\n  profiles:\n    - default\n  telemetry:\n    type: Istiod\n  tracing:\n    sampling: 10000\n    type: Jaeger\n  version: v2.6\n</code></pre>"},{"location":"servicemesh/#2-aggiunta-di-servizi-in-service-mesh","title":"2. Aggiunta di servizi in Service Mesh","text":""},{"location":"servicemesh/#21-definizione-servicemeshmemberroll","title":"2.1 Definizione ServiceMeshMemberRoll","text":"<p>Questo oggetto fornisce agli amministratori di OpenShift Service Mesh un modo per delegare le autorizzazioni e per aggiungere progetti a una mesh.</p> <pre><code>apiVersion: maistra.io/v1\nkind: ServiceMeshMemberRoll\nmetadata:\n  name: default\n  namespace: istio-system\nspec:\n  members:\n    - bookinfo\n</code></pre> <p>La Service Mesh definisce anche le network policy nella control plane della Service Mesh e nei namespace partecipanti, regolando il traffico all'interno della mesh.</p> <pre><code>oc get netpol -n bookinfo\n\nistio-expose-route-basic\nistio-mesh-basic\n</code></pre>"},{"location":"servicemesh/#3-deploy-bookinfo","title":"3. Deploy Bookinfo","text":"<p>L'applicazione Bookinfo visualizza informazioni simili ad un negozio di libri online. L'applicazione mostra una pagina che descrive il libro, i suoi dettagli (ISBN, numero di pagine e altre informazioni) e le recensioni ricevute.</p> <p>L'applicazione Bookinfo \u00e8 composta da questi microservizi:</p> <p>Il microservizio productpage chiama i microservizi details e reviews per popolare la pagina. Il microservizio details contiene informazioni sui libri. Il microservizio reviews contiene le recensioni dei librie e chiama il microservizio dei ratings. Il microservizio dei ratings contiene le informazioni sulle classifiche dei libri che accompagnano le recensioni.</p> <p>Esistono tre versioni del microservizio reviews:</p> <ul> <li>La versione v1 non chiama il servizio di ratings.</li> <li>La versione v2 chiama il Servizio reviews e visualizza ogni valutazione con stelle nere.</li> <li>La versione v3 chiama il Servizio reviews e visualizza ogni valutazione con stelle rosse.</li> </ul> <p>-&gt; bookinfo.yaml</p>"},{"location":"servicemesh/#4-sidecar-injection","title":"4. Sidecar Injection","text":"<p>Annotations nei deployment per abilitare l'injection del proxy istio</p> <pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n    [...]\nspec:\n  template:\n    metadata:\n      annotations:\n        sidecar.istio.io/inject: 'true'\n</code></pre> <p>E' possibile sfruttare l'injection automatica dei sidecar configurando una label direttamente sul namespace: </p> <pre><code>$ oc label namespace &lt;nome_namespace&gt; istio-injection=enabled\n</code></pre>"},{"location":"servicemesh/#5-versioning-del-deployment","title":"5. Versioning del deployment","text":"<pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n    [...]\nspec:\n  template:\n    metadata:\n      labels:\n        app: reviews\n        version: v1\n</code></pre>"},{"location":"servicemesh/#6-definizione-ingressgateway","title":"6. Definizione IngressGateway","text":"<p>Una risorsa gateway rappresenta un bilanciatore di carico che opera ai margini della mesh, gestendo le connessioni HTTP/TCP in entrata e in uscita. La sua specifica descrive:</p> <ul> <li>un set di porte che devono essere esposte</li> <li>il tipo di protocollo da utilizzare</li> <li>la configurazione SNI per il bilanciatore di carico e altro ancora.</li> </ul> <pre><code>apiVersion: networking.istio.io/v1beta1\nkind: Gateway\nmetadata:\n  name: bookinfo-gateway\nspec:\n  selector:\n    istio: ingressgateway # use istio default controller\n  servers:\n  - port:\n      number: 8080\n      name: http\n      protocol: HTTP\n    hosts: \n    - \"*\"\n</code></pre> <p>A differenza di una Ingress o Rotta standard, non include alcuna configurazione di routing del traffico. Il routing del traffico \u00e8 invece configurato utilizzando l'oggetto VirtualService.</p>"},{"location":"servicemesh/#7-definizione-virtualservices","title":"7. Definizione VirtualServices","text":"<p>Per specificare il routing e per far funzionare il gateway come previsto, bisogna anche associare il gateway a un virtualService:</p> <pre><code>apiVersion: networking.istio.io/v1beta1\nkind: VirtualService\nmetadata:\n  name: bookinfo\nspec:\n  hosts:\n  - \"*\"\n  gateways:\n  - bookinfo-gateway\n  http:\n  - match:\n    - uri:\n        exact: /productpage\n    - uri:\n        prefix: /static\n    - uri:\n        exact: /login\n    - uri:\n        exact: /logout\n    - uri:\n        prefix: /api/v1/products\n    route:\n    - destination:\n        host: productpage\n        port:\n          number: 9080\n</code></pre>"},{"location":"servicemesh/#8-gestione-del-traffico","title":"8. Gestione del traffico","text":"<p>Per il microservizio reviews definiamo un oggetto DestinationRule per identificare i subset in base alla versione del deployment, configura quindi tre diversi sottoinsiemi:</p> <pre><code>apiVersion: networking.istio.io/v1beta1\nkind: DestinationRule\nmetadata:\n  name: reviews\n  namespace: bookinfo\nspec:\n  host: reviews\n  subsets:\n    - labels:\n        version: v1\n      name: v1\n    - labels:\n        version: v2\n      name: v2\n    - labels:\n        version: v3\n      name: v3\n  trafficPolicy:\n    loadBalancer:\n      simple: RANDOM\n</code></pre>"},{"location":"servicemesh/#scenario-1-routing","title":"Scenario 1 (Routing)","text":"<p>Veicoliamo tutto il traffico solo per la versione v1 di review e poi solo per v2</p> <pre><code>apiVersion: networking.istio.io/v1beta1\nkind: VirtualService\nmetadata:\n  name: reviews\nspec:\n  hosts:\n  - reviews\n  http:\n  - route:\n    - destination:\n        host: reviews\n        subset: v1   #v2\n</code></pre>"},{"location":"servicemesh/#scenario-2-shifting","title":"Scenario 2 (Shifting)","text":"<p>Veicoliamo una percentuale di traffico sulle 2 istanze v1 e v2</p> <pre><code>apiVersion: networking.istio.io/v1beta1\nkind: VirtualService\nmetadata:\n  name: reviews\nspec:\n  hosts:\n    - reviews\n  http:\n  - route:\n    - destination:\n        host: reviews\n        subset: v1\n      weight: 80\n    - destination:\n        host: reviews\n        subset: v2\n      weight: 20\n</code></pre>"},{"location":"servicemesh/#scenario-3-http-header","title":"Scenario 3 (Http header)","text":"<p>Set header http, veicola traffico solo su v2 solo se corrisponde un determinato utente</p> <pre><code>apiVersion: networking.istio.io/v1beta1\nkind: VirtualService\nmetadata:\n  name: reviews\nspec:\n  hosts:\n  - reviews\n  http:\n  - match:\n    - headers:\n        end-user:\n          exact: jason\n    route:\n    - destination:\n        host: reviews\n        subset: v2\n  - route:\n    - destination:\n        host: reviews\n        subset: v3\n</code></pre>"},{"location":"servicemesh/#scenario-4-fault-injection","title":"Scenario 4 (Fault Injection)","text":"<p>Fault injection microservizio details e osservere jaeger</p> <pre><code>apiVersion: networking.istio.io/v1beta1\nkind: DestinationRule\nmetadata:\n  name: details\nspec:\n  host: details\n  subsets:\n  - name: v1\n    labels:\n      version: v1\n---\napiVersion: networking.istio.io/v1beta1\nkind: VirtualService\nmetadata:\n  name: details\nspec:\n  hosts:\n  - details\n  http:\n  - fault:\n      abort:\n        httpStatus: 555\n        percentage:\n          value: 100\n    route:\n    - destination:\n        host: details\n        subset: v1\n</code></pre>"},{"location":"servicemesh/#scenario-5-delay","title":"Scenario 5 (Delay)","text":"<p>Delay</p> <pre><code>apiVersion: networking.istio.io/v1beta1\nkind: VirtualService\nmetadata:\n  name: details\nspec:\n  hosts:\n  - details\n  http:\n  - fault:\n      delay:\n        fixedDelay: 7s\n        percentage:\n          value: 100\n    route:\n    - destination:\n        host: details\n        subset: v1\n</code></pre>"},{"location":"servicemesh/#scenario-6-mirroring","title":"Scenario 6 (Mirroring)","text":"<p>Mirroring del traffico osservare con grafana Il mirroring invia una copia del traffico live a un servizio mirrorato.</p> <pre><code>apiVersion: networking.istio.io/v1beta1\nkind: VirtualService\nmetadata:\n  name: reviews\nspec:\n  hosts:\n    - reviews\n  http:\n  - route:\n    - destination:\n        host: reviews\n        subset: v1\n      weight: 100\n    mirror:\n        host: reviews\n        subset: v2\n    mirrorPercentage:\n    value: 100.0\n</code></pre>"},{"location":"servicemesh/#scenario-7-circuit-breaking","title":"Scenario 7 (Circuit breaking)","text":"<p>Il circuit breaking \u00e8 un pattern importante per la creazione di applicazioni microservice resilienti. Il circuit breaking consente di scrivere applicazioni che limitano l'impatto di guasti, picchi di latenza e altri effetti indesiderati delle peculiarit\u00e0 della rete.</p> <pre><code>apiVersion: networking.istio.io/v1beta1\nkind: DestinationRule\nmetadata:\n  name: details\nspec:\n  host: details\n  subsets:\n  - name: v1\n    labels:\n      version: v1\n  trafficPolicy:\n    connectionPool:\n      tcp:\n        maxConnections: 1\n      http:\n        http1MaxPendingRequests: 1\n        maxRequestsPerConnection: 1\n    outlierDetection:\n      consecutive5xxErrors: 1\n      interval: 1s\n      baseEjectionTime: 3m\n      maxEjectionPercent: 100\n</code></pre> <p>Queste regole indicano che se si supera pi\u00f9 di una connessione e contemporanea, dovrebbero verificarsi alcuni errori quando istio-proxy tenta di aprire ulteriori richieste e connessioni.</p> <pre><code>maxConnections: 1 \nhttp1MaxPendingRequests: 1\n</code></pre>"}]}